# 算法精解C语言描述

### 算法设计的一般方法

#### 随机法

随机法依赖随机数的统计特性。一个应用随机法的例子是快速排序。为了获得较高的性能，快速排序依赖于每一次要如何划分，为了实现这一步，理想的方法是在划分之前获得中间值。可是为了确定这个中间值需要遍历所有的数据。作为替代的方法，随机选择一个作为划分的依据。快速排序的平均性能很不错，因为随机数的正态分布使得划分的结果是相对平衡的。

#### 分治法

分治法包含3个步骤：分解，求解与合并。在分解阶段，将数据分解为更小、更容易管理的部分。在求解阶段，对每个分解出的部分进行处理。在合并阶段，将每部分处理的结果进行合并。一个分治法的例子是归并排序。

#### 动态规划

动态规划同分治法类似，都是将较大的问题分解为子问题最后将结果合并。然而，它们处理问题的方式与子问题之间的关系有关。在分治法中，每一个子问题都是独立的。为此，以递归的方式解决每一个子问题，然后将结果与其他问题的结果合并。在动态规划中，子问题之间并不是独立的。换句话说，子问题之间可能有关联。这类问题采用动态规划比分治法更合适。

#### 贪心法

贪心法在求解问题时总能够做出在当前的最佳选择。换句话说，不是从整体最优上考虑，而仅仅是在某种意义上的局部最优解。遗憾的是，当前的最优解长远来看未必是最优的。因此，贪心法并不会一直产生最优解。然而，在某些方面来说，贪心法确实是最佳选择。一个采用贪心法的例子是霍夫曼编码，这是一个数据压缩算法。

#### 近似法

近似法并不计算出最优解，相反，它只计算出“足够好”的解。通常利用近似法解决那些计算成本很高又因为其本身十分有价值而不愿放弃的问题。推销员问题是一个通常会用近似法去求解的问题。

### 递归

#### 基本递归

一种强大的方法，允许一个问题以其自身来越小的形式来定义自己。在计算机领域中，通过使用递归函数来解决带有递归性质的问题，也就是用函数调用自身。

```C++
// 阶乘问题
// F(n)=n*F(n-1);F(0)=F(1)=1
int fact(int n){
    if(n < 0){
        return 0;
    }else if(n == 0){
        return 1;
    }else if(n == 1){
        return 1;
    }else{
        return n * fact(n-1);
    }
}
```

栈是用来存储函数调用的绝好方案，正式由于其后进先出的特点精确满足了函数调用和返回的顺序，然而，使用栈也有一些缺点，栈维护了每个函数调用的信息直到函数返回后才释放，这需要占用相当大的空间，尤其在程序中使用了许多调用的情况下。除此之外，因为大量的信息需要保存和恢复，因此生产和销毁活跃记录需要消耗一定的时间。如此一来当函数嗲用的开销变得很大时，就需要考虑应该采用迭代的方案。
可以采用一种称为尾递归的特殊递归方式来避免前面提到的这些缺点。

#### 尾递归

递归的另一种形式，这里编译器会为此产生优化的代码。大多数编译器能够识别为递归。
如果一个函数中所有的递归形式的嗲用都出现在函数末尾，称这个递归函数是尾递归的。当递归调用时整个函数体中最后执行的语句且不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为现代大多数编译器会利用这个特点自动生产优化的代码。

```C++
// 阶乘问题
// F(n,a)=F(n-1,n*a) n>1
// F(n,a)=a n=0,n=1
int facttail(int n, int a){
    if(n < 0){
        return 0;
    }else if(n == 0){
        return 1;
    }else if(n == 1){
        return a;
    }else{
        return facttail(n-1,n*a);
    }
}
```

## 数据结构

### 链表

#### 单链表

最简单的链表，元素之间由一个单独的指针链接。这种结构的链表允许从第一个元素遍历到最后一个元素。

#### 双向链表

这种形式的链表元素之间通过两个指针链接。双向链表可以正向遍历，也可以反向遍历。

#### 循环链表

这种形式的链表最后一个元素的指针指向链表的首元素。而不是设置为NULL。这种结构的链表允许循环遍历。

### 栈和队列

#### 栈

按照后进先出（LIFO）的顺序存储和检索数据的高效数据结构，它按照元素的顺序与存储元素的顺序相反。

#### 队列

按照先进先出（FIFO）的顺序存储和检索数据的高效数据结构，它按照存储元素的先后顺序检索元素。

### 集合

#### 集合的基本准则

集合能够采用基本的数学定义来描述，和其他数据对象一样，集合包含一些基本定义、基本的操作以及属性。

#### 集合抽象数据类型

这种抽象数据类型基于数学中集合的概念，集合是成员彼此之间相关，但每个成员在集合中只出现一次的无序聚集。

### 哈希表

哈希表支持一种最有效的检索方法：散列。从根本上来说，一个哈希表包含一个数组，通过特殊的索引值来访问数组中的元素。哈希表的主要思想是通过一个哈希函数，在所有可能的键与槽位之间建立一张映射表。哈希函数每次接受一个键将返回与键相对应的哈希编码或哈希值。键的数据类型可能多种多样，但哈希值的类型只能是整型。

#### 链式哈希表

将数据存储在“桶”中的哈希表。每个“桶”都是一个链表，且链表的容量能够随着冲突的增加而增大。

#### 开地址哈希表

将数据存储在表本身中，而不是“桶”中的哈希表。它通过各种探查方法来避免冲突问题。

#### 选择哈希函数

这是哈希算法的核心问题：将键随机地分散到表中，使冲突最小化。因此，选择一个能够实现这一过程的哈希函数尤为重要。

#### 冲突解决

当有多个键映射到相同的索引时解决键冲突问题。链式哈希表以固有的方式来解决冲突。开地址哈希表通过各种形式的探查方法来解决冲突。



