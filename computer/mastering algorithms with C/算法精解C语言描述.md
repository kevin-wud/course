# 算法精解C语言描述

### 算法设计的一般方法

#### 随机法

随机法依赖随机数的统计特性。一个应用随机法的例子是快速排序。为了获得较高的性能，快速排序依赖于每一次要如何划分，为了实现这一步，理想的方法是在划分之前获得中间值。可是为了确定这个中间值需要遍历所有的数据。作为替代的方法，随机选择一个作为划分的依据。快速排序的平均性能很不错，因为随机数的正态分布使得划分的结果是相对平衡的。

#### 分治法

分治法包含3个步骤：分解，求解与合并。在分解阶段，将数据分解为更小、更容易管理的部分。在求解阶段，对每个分解出的部分进行处理。在合并阶段，将每部分处理的结果进行合并。一个分治法的例子是归并排序。

#### 动态规划

动态规划同分治法类似，都是将较大的问题分解为子问题最后将结果合并。然而，它们处理问题的方式与子问题之间的关系有关。在分治法中，每一个子问题都是独立的。为此，以递归的方式解决每一个子问题，然后将结果与其他问题的结果合并。在动态规划中，子问题之间并不是独立的。换句话说，子问题之间可能有关联。这类问题采用动态规划比分治法更合适。

#### 贪心法

贪心法在求解问题时总能够做出在当前的最佳选择。换句话说，不是从整体最优上考虑，而仅仅是在某种意义上的局部最优解。遗憾的是，当前的最优解长远来看未必是最优的。因此，贪心法并不会一直产生最优解。然而，在某些方面来说，贪心法确实是最佳选择。一个采用贪心法的例子是霍夫曼编码，这是一个数据压缩算法。

#### 近似法

近似法并不计算出最优解，相反，它只计算出“足够好”的解。通常利用近似法解决那些计算成本很高又因为其本身十分有价值而不愿放弃的问题。推销员问题是一个通常会用近似法去求解的问题。

### 递归

#### 基本递归

一种强大的方法，允许一个问题以其自身来越小的形式来定义自己。在计算机领域中，通过使用递归函数来解决带有递归性质的问题，也就是用函数调用自身。

```C++
// 阶乘问题
// F(n)=n*F(n-1);F(0)=F(1)=1
int fact(int n){
    if(n < 0){
        return 0;
    }else if(n == 0){
        return 1;
    }else if(n == 1){
        return 1;
    }else{
        return n * fact(n-1);
    }
}
```

栈是用来存储函数调用的绝好方案，正式由于其后进先出的特点精确满足了函数调用和返回的顺序，然而，使用栈也有一些缺点，栈维护了每个函数调用的信息直到函数返回后才释放，这需要占用相当大的空间，尤其在程序中使用了许多调用的情况下。除此之外，因为大量的信息需要保存和恢复，因此生产和销毁活跃记录需要消耗一定的时间。如此一来当函数嗲用的开销变得很大时，就需要考虑应该采用迭代的方案。
可以采用一种称为尾递归的特殊递归方式来避免前面提到的这些缺点。

#### 尾递归

递归的另一种形式，这里编译器会为此产生优化的代码。大多数编译器能够识别为递归。
如果一个函数中所有的递归形式的嗲用都出现在函数末尾，称这个递归函数是尾递归的。当递归调用时整个函数体中最后执行的语句且不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为现代大多数编译器会利用这个特点自动生产优化的代码。

```C++
// 阶乘问题
// F(n,a)=F(n-1,n*a) n>1
// F(n,a)=a n=0,n=1
int facttail(int n, int a){
    if(n < 0){
        return 0;
    }else if(n == 0){
        return 1;
    }else if(n == 1){
        return a;
    }else{
        return facttail(n-1,n*a);
    }
}
```

## 数据结构

### 链表

#### 单链表

最简单的链表，元素之间由一个单独的指针链接。这种结构的链表允许从第一个元素遍历到最后一个元素。

#### 双向链表

这种形式的链表元素之间通过两个指针链接。双向链表可以正向遍历，也可以反向遍历。

#### 循环链表

这种形式的链表最后一个元素的指针指向链表的首元素。而不是设置为NULL。这种结构的链表允许循环遍历。

